---
title: "callWithSyncFeeERC2771 - Overview"
description: "Learn how to use Gelato's callWithSyncFeeERC2771 SDK method for relaying transactions with on-chain payments and ERC2771 authentication."
---

This guide explains how to use the `callWithSyncFeeERC2771` SDK method, which facilitates on-chain payments with ERC2771 authentication.

<Warning>
  **Important Security Notes:**
  - If you plan to use ERC-2771 with a `multicall` method or any other method using `delegateCall()`, please read carefully the section [Avoid ERC-2771-risks](/Relay/Security-considerations/ERC2771-DelegateCall-vulnerability).
  - If you are using `@gelatonetwork/relay-sdk` v3 or contracts from the package `@gelatonetwork/relay-context` v2, please follow [this migration guide](/Relay/Additional-Resources/ERC2771-Migration-Guide).
  - Please proceed to our [Security Considerations page](/Relay/Security-considerations/Overview) and read it thoroughly before advancing with your implementation. It is crucial to understand all potential security risks and measures to mitigate them.
</Warning>

After reading this page, you'll:
- Know how to use the `callWithSyncFeeERC2771` SDK method.
- See code examples to help you send a relay request quickly.
- Learn how to pay for transactions using the provided values for `fee`, `feeToken`, and `feeCollector`.

## Overview

The `callWithSyncFeeERC2771` method uses the `syncFee` payment method with ERC-2771 support.

**Youtube video here**

## Paying for Transactions

When using `callWithSyncFeeERC2771`, the target contract assumes responsibility for transferring the fee to Gelato's fee collector during transaction execution. The target contract needs to know:
- `fee`: The transfer amount.
- `feeToken`: The token to be transferred.
- `feeCollector`: The destination address for the fee.

Gelato provides tools within the Relay Context Contracts to manage this:

<Card title="Using GelatoRelayContextERC2771">
  By inheriting the `GelatoRelayContextERC2771` contract, you can transfer the fee using:
  - `_transferRelayFee()`
  - `_transferRelayFeeCapped(uint256 maxFee)`
  The inherited contract decodes `fee`, `feeToken`, and `feeCollector` automatically. Gelato Relay backend calculates the `fee` using Gelato's Fee Oracle.
</Card>

<Card title="Using GelatoRelayFeeCollectorERC2771">
  Alternatively, inheriting `GelatoRelayFeeCollectorERC2771` means Gelato decodes only the `feeCollector`. You must provide `fee` and `feeToken` on-chain (e.g., hardcoded - not recommended, or embedded in the payload). The suggested way is to calculate the `fee` with Gelato's Fee Oracle.
</Card>

This modular design ensures smooth integration with Gelato's fee handling mechanisms.

### Setting `maxFee` for Your Transaction

Setting a maximum fee (`maxFee`) is strongly advised to ensure transaction costs stay below a limit.
- The `_transferRelayFeeCapped(uint256 maxFee)` method in `GelatoRelayContextERC2771` provides an easy way to set `maxFee`.
- If using `GelatoRelayFeeCollectorERC2771`, the recommended way is to calculate the `fee` with Gelato's Fee Oracle (via `getEstimatedFee()` in the Relay SDK) and pass this as your `maxFee`.

## SDK Methods

### `callWithSyncFeeERC2771`
Initiates the signing of ERC2771 requests and forwards the request to Gelato.

```typescript
const callWithSyncFeeERC2771 = async (
  request: CallWithSyncFeeERC2771Request | CallWithSyncFeeConcurrentERC2771Request,
  signerOrProvider: ethers.BrowserProvider | ethers.Signer,
  options?: RelayRequestOptions,
  apiKey?: string
): Promise<RelayResponse>
```

### `getSignatureDataERC2771`
Starts the signing process and returns the signature and message.

```typescript
getSignatureDataERC2771 = (
  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,
  signerOrProvider: ethers.BrowserProvider | ethers.Signer,
  type: 'CallWithSyncFee' | 'ConcurrentCallWithSyncFee'
): Promise<SignatureData>
```

### `getDataToSignERC2771`
Provides message data for external signing.

```typescript
getDataToSignERC2771 = (
  request: CallWithERC2771Request | CallWithConcurrentERC2771Request,
  type: 'CallWithSyncFee' | 'ConcurrentCallWithSyncFee',
  signerOrProvider?: ethers.BrowserProvider | ethers.Signer
): Promise<PayloadToSign>
```

### `callWithSyncFeeERC2771WithSignature`
Sends pre-signed requests to Gelato.

```typescript
const callWithSyncFeeERC2771WithSignature = async (
    struct: CallWithERC2771Struct | CallWithConcurrentERC2771Struct,
    syncFeeParams: BaseCallWithSyncFeeParams,
    signature: string,
    options?: RelayRequestOptions,
    apiKey?: string
): Promise<RelayResponse>
```

### Optional Parameters (`RelayRequestOptions`)
```typescript
type RelayRequestOptions = {
  gasLimit?: BigNumberish;
  retries?: number;
};
```

## Sending a Request

Two ways to send `callWithSyncFeeERC2771` requests:
1.  **Sequentially**
2.  **Concurrently (SDK v5.1.0+)**

By default, `callWithSyncFeeERC2771` uses the sequential method.

## Request Body

<CodeGroup>
```typescript title="Sequential Request"
type CallWithSyncFeeERC2771Request = {
  chainId: BigNumberish;
  target: string;
  data: BytesLike;
  user: string;
  userDeadline?: BigNumberish;
  feeToken: string;
  isRelayContext?: boolean;
  isConcurrent?: false;
  userNonce?: BigNumberish;
};
```
```typescript title="Concurrent Request"
type CallWithSyncFeeConcurrentERC2771Request = {
  chainId: BigNumberish;
  target: string;
  data: BytesLike;
  user: string;
  userDeadline?: BigNumberish;
  feeToken: string;
  isRelayContext?: boolean;
  isConcurrent: true;
  userSalt?: string;
};
```
</CodeGroup>

## Example Code (using `GelatoRelayContextERC2771`)

<Steps>
### 1. Deploy a `GelatoRelayContextERC2771` compatible contract

```solidity
// SPDX-License-Identifier: MIT
pragma solidity 0.8.17;

import {
    GelatoRelayContextERC2771
} from "@gelatonetwork/relay-context/contracts/GelatoRelayContextERC2771.sol";

contract CounterRelayContextERC2771 is GelatoRelayContextERC2771 {
    mapping(address => uint256) public contextCounter;
    event IncrementCounter(address indexed msgSender);

    function increment() external onlyGelatoRelayERC2771 {
        _transferRelayFee();
        contextCounter[_getMsgSender()]++;
        emit IncrementCounter(_getMsgSender());
    }

    function incrementFeeCapped(uint256 maxFee) external onlyGelatoRelayERC2771 {
        _transferRelayFeeCapped(maxFee);
        contextCounter[_getMsgSender()]++;
        emit IncrementCounter(_getMsgSender());
    }
}
```

### 2. Import `GelatoRelaySDK` into your front-end

```typescript
import { GelatoRelay, CallWithSyncFeeERC2771Request } from "@gelatonetwork/relay-sdk";
import { ethers } from "ethers";

const relay = new GelatoRelay({
  contract: {
    relayERC2771: "0xb539068872230f20456CF38EC52EF2f91AF4AE49" // Example for Sepolia
  }
});
```

### 3. Send the payload to Gelato

```typescript
async function main() {
  // @ts-ignore
  const provider = new ethers.BrowserProvider(window.ethereum);
  const signer = await provider.getSigner();
  const user = await signer.getAddress();

  const counterContractAddress = "<YOUR_COUNTER_CONTRACT_ADDRESS>";
  const contractAbi = ["function increment()", "function incrementFeeCapped(uint256 maxFee)"];
  const targetContract = new ethers.Contract(counterContractAddress, contractAbi, signer);
  const feeToken = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";

  // Example 1: Calling increment()
  const { data: incrementTxData } = await targetContract.increment.populateTransaction();
  const incrementRequest: CallWithSyncFeeERC2771Request = {
    chainId: (await provider.getNetwork()).chainId,
    target: counterContractAddress,
    data: incrementTxData,
    user: user,
    feeToken: feeToken,
    isRelayContext: true,
  };
  const incrementRelayResponse = await relay.callWithSyncFeeERC2771(incrementRequest, signer);
  console.log("Increment Relay taskId:", incrementRelayResponse.taskId);

  // Example 2: Calling incrementFeeCapped(maxFee)
  const estimatedFee = await relay.getEstimatedFee(
    (await provider.getNetwork()).chainId,
    feeToken,
    BigInt("200000"),
    false
  );
  const maxFee = estimatedFee * BigInt(2);
  const { data: incrementFeeCappedTxData } = await targetContract.incrementFeeCapped.populateTransaction(maxFee);
  const incrementFeeCappedRequest: CallWithSyncFeeERC2771Request = {
    chainId: (await provider.getNetwork()).chainId,
    target: counterContractAddress,
    data: incrementFeeCappedTxData,
    user: user,
    feeToken: feeToken,
    isRelayContext: true,
  };
  const cappedRelayResponse = await relay.callWithSyncFeeERC2771(incrementFeeCappedRequest, signer);
  console.log("IncrementFeeCapped Relay taskId:", cappedRelayResponse.taskId);
}
```
</Steps>
